/**
	* ChatService.
	* This class is used to implement the service that make possible to chat with other host in the mesh network
	* @extends Service
	* @namespace
	*/

class ChatService extends Service {

	/**
		* The constructor
		* @param {Connection} connection connection used to send service data
		* @param {Object} context the context on which the data should be rendered

		*/
	constructor(connection, context) {

		//Build the parent
		super(connection, context)

		//Array of chats
		this.chats = [];

		//Currently active chat
		this.activeChat = null;

		//Identifiers to get DOM objects
		this.identifiers = {

			textField : 'chat-service-input'

		}

	}

	/**
	* Loads a chat with the desired host
	* @param {String} uid the uid of the host
	*/
	load(uid) {

		//Check whether a chat with the given uid halready exists
		let chat = this.getChat(uid);

		if (chat == null) {

			this.activeChat = this.createChat(uid)

		}
		else {

			this.activeChat = chat;

		}

		//Once we have a chat to load, do it
		this.context.html(ChatRender.chat(this.activeChat, this))

		//Scroll down
		this.activeChat.scrollToBottom()

	}

	/**
	* Unloads the chat clearing the context
	*/
	unload() {

		//Service is being unloaded, be ready for it by setting active chat = null & clearing the context
		this.activeChat = null;
		this.context.html('')

	}

	/**
		* Method triggered when the chat service received some data.
		* @param {Object} from The uid of the sender
		* @param {Object} data The parsed JSON data
		*/
	onData(from, data) {

		//We implemented only string messages, but you can do whatever you need.
		if (data.type == 'string') {

			if (this.getChat(from) == null) {

				//Check that a chat exists, if not create it
				this.createChat(from);

			}

			this.getChat(from).onMessageReceive(data.message)

		}

	}

	/**
	* Abstraction made to update the chat object with the new message sent.
	* This method is the only one that will be called directly
	* @param {Object} message the message to send
	*/
	sendMessage(message) {

		if (message.length == 0) {

			return;

		}

		this.activeChat.onMessageSend(message);

		/*
			* @desc Every service should overwrite this method to handle incoming data.
			* @to The uid of the target
			* @param data The object to be stringyfied to JSON. Note that you have to provide only the service and his relative data
			*/

		this.sendData(this.activeChat.uid, {

			service : 'chat',
			data : {
			    type : 'string',
			    message : message
			}

		})

	}

	/**
	* Creates a new chat object for the host
	* @param {String} uid the uid of the host
	* @return {Chat} the new chat object
	*/
	createChat(uid) {

		let chat_context_id = 'chat-'+uid;
		let new_chat = new Chat(uid, this.connection.hostNameForUid(uid), chat_context_id)

		this.chats.push(new_chat)

		return new_chat;

	}

	/**
	* Returns the chat corresponding to the provided uid
	* @param {String} uid the uid of the host
	* @return {Chat} the chat object
	*/
	getChat(uid) {


		if (this.chats.length > 0) {

			for (var i = 0; i < this.chats.length; i++) {

				if (this.chats[i].uid == uid) {

					return this.chats[i];

				}

			}

		}

		return null;

	}

	/**
	* Triggered when the user hit enter to send a message.
	* This method sends the message written in the textfield upon user interaction
	* @param {Event} event the keyboard event
	*/
	onUserInteraction(event) {

		//If the event was generated by a enter hit or a send-button press then:
		if (event == undefined || event.keyCode == 13) {

			//Retrive the Input DOM element
			let input = document.getElementById(this.identifiers.textField);

			if (input.value != '') {

				//Send the message
				this.sendMessage(input.value);

				//Clear the input
				input.value = '';

			}

		}

	}

}
